# 哈希表

## 哈希表基本知识

哈希表是根据关键码的值而直接进行访问的数据结构。

![哈希表1](https://file1.kamacoder.com/i/algo/20210104234805168.png)

**一般哈希表都是用来快速判断一个元素是否出现集合里**

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

### 哈希函数

![哈希表2](https://file1.kamacoder.com/i/algo/2021010423484818.png)

### 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。



![哈希表3](https://file1.kamacoder.com/i/algo/2021010423494884.png)

**拉链法**

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了

**线性探测法**

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5](https://file1.kamacoder.com/i/algo/20210104235109950.png)


## 常见的三种哈希结构

- 数组
- set （集合）
- map(映射)

##  242.有效的字母异位词

### 简单思路

写这道题的时候刚刚接触哈希表，所以随想录给的方法有一点点复杂，我想的方法直接就是通过字典将s中字母的出现次数记录下来，然后在t表中再减去出现次数，如果最后所有字典中的values都是0则为True

### 详细思路

```python
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        hashmap = dict()
        for x in s:
            if x not in hashmap:
                hashmap[x] = 1
            else:
                hashmap[x] +=1
        
        for x in t:
            #如果出现不存在的数直接返回false
            if x not in hashmap:
                return False
            else:
                hashmap[x] -=1
        for value in hashmap.values():
            #如果存在值不等于0就返回false
            if value!=0 :
                return False
        
        return True
```



##  383. 赎金信

和上一题思路差不多，使用哈希表给字符串ransomNote里面的字母统计出现次数，然后根据magazine中字母的出现次数减去哈希表的出现次数，操作过后如果还有value大于0则说明ransomNote存在magazine没有的字母，所以返回false。

### 详细思路

```python
class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        """
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        """
        hashmap = dict()
        for x in ransomNote:
            if x not in hashmap:
                hashmap[x] = 1
            else:
                hashmap[x] +=1
        
        for x in magazine:
            if x in hashmap:
                hashmap[x] -= 1
        for value in hashmap.values():
            if value>0 :
                return False
        return True
```



##  349. 两个数组的交集

## 202. 快乐数

### 简单思路

当n不是快乐数的时候，两位的平方和会无限循环。所以可以使用一个set记录已经出现的数，如果出现的数已经在set里就说明已经出现了循环，直接返回false。



## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

暴力解法复杂度太高，比较好的解法是对于每一个元素x，从集合里面寻找target-x。

```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        records = dict()
        
        #这是第一次遇到enumerate(),效果是从数组中提取出索引和值
        for index, value in enumerate(nums):
            if target-value in records:
                return[records[target-value],index]


            records[value] = index
        return []
```







## **454.四数相加II** 

### 简单思路

大概思路就是把四个数组划分为两个部分：第一个部分使用字典统计不同情况下数字出现的次数，第二个部分寻找是否存在和与字典中key加起来为零的情况，如果有的话计数。

### 详细思路

```python	
class Solution(object):
    def fourSumCount(self, nums1, nums2, nums3, nums4):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type nums3: List[int]
        :type nums4: List[int]
        :rtype: int
        """
        #创建字典保存n1和n2所有可能出现的和以及计数
        hashmap =dict()
        for n1 in nums1:
            for n2 in nums2:
                if (n1+n2) not in hashmap:
                    hashmap[n1+n2] = 1
                else:
                    hashmap[n1+n2] += 1
        
        count = 0、
        #在n3和n4的和中寻找是否存在在与n1+n2相加等于0的和
        for n3 in nums3:
            for n4 in nums4:
                if (-n3-n4) in hashmap:
                    count += hashmap[-n3-n4]
        
        return count
```


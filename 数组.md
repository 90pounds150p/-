### **第一章  数组**

####  **704. 二分查找** 

##### 简单回答

最基础的二分查找代码，主要思想就是在一个排序好的数组中通过比对中间值和目标值的大小来判断目标值在中间值的哪一边，并以此来更新左和右。

##### 详细回答

我先贴一下我一开始的答案：

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        #初始化左边和右边
        left = 0 
        right = len(nums)-1
        mid = (left + right)/2 #mid实际上也没有必要在这里定义
        for mid in range(len(nums)): #当中间值在数组中的时候，后面思考感觉没有必要加这个条件
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
                mid = (left + right)/2
            else:
                right = mid - 1
                mid = (left + right)/2

        return -1
```

因为好久没有写代码，所以代码中存在多处没有必要存在的东西，正常的代码应该是这样的：

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left = 0
        right = len(nums) - 1
        while left <= right :
            mid = (left + right) // 2
            if nums[mid] == target :
                return mid
            elif nums[mid] < target :
                left = mid +1
            elif nums[mid] > target :
                right = mid - 1
        return -1
```

####  **27. 移除元素**

##### 简单回答

这道题有三种方法：

- 暴力解决：

  使用两次循环，如果在第一次循环中检测到目标值，则通过第二次循环删除该值并将数组缩短一位。

- 双指针：

  使用快慢指针的方法，移动快指针，如果快指针对应的值不是目标值，就将其移动（复制）到慢指针对应的值中。

- 栈方法：

  想象目标的数组为一个栈，遍历原数组，将不需要删除的元素直接放入栈中。

##### 详细回答

###### 暴力解决

```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i, l = 0, len(nums)
        while i < l:
            if nums[i] == val: # 找到等于目标值的节点
                for j in range(i+1, l): # 移除该元素，并将后面元素向前平移
                    nums[j - 1] = nums[j]
                l -= 1
                i -= 1
            i += 1
        return l
```

相比于其余的两种方法，我觉得暴力解决的方法既慢又容易出错。





###### 双指针

```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        fast = 0 #快指针
        slow = 0 #慢指针
        size = len(nums)
        while fast<size: #快指针遍历整个数组
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow +=1
            fast +=1
        return slow
```



###### 栈方法

```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        stack_size=0
        for x in nums:
            if x != val:
                nums[stack_size] = x
                stack_size +=1
        return stack_size
            
```



#### **977.有序数组的平方** 

##### 简单回答

两种方法：

- 平方加排序
- 双指针：两个指针指向最左边和最右边，数组的特性是平方后最大的数都在数组两边，所以可以对比左右两边平方后的数，大的数填在新数组的左右边并往中间移动指针。

##### 详细方法

###### 暴力方法

```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        #先平方
        for i in range(len(nums)):
            nums[i] = nums[i]*nums[i]

        #后排序
        nums.sort()
        return nums
```

没啥必要看的。。。



###### 双指针

```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        l = len(nums)
        ans = [0]*l
        left, right, pls = 0, l-1, l-1
        while left <= right:
            if nums[left]*nums[left]<nums[right]*nums[right]:
                ans[pls]=nums[right]*nums[right]
                right-=1
                pls-=1
            else:
                ans[pls]=nums[left]*nums[left]
                left+=1
                pls-=1
        return ans
```

值得记得的是可以通过`ans = [0]*l`来创造一个长度相同的新数组
